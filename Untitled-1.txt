// pyxom/pyodide/evaluator.ts

import type { PyodideInterface } from 'pyodide';
type PyProxy = any;
import type { ExerciseData, TestCase, StaticCodeCheck, SingleTestRunResult, StaticCheckRunResult, AttemptResult } from '@/types/types'; // Ajusta la ruta si es necesario

let pyodideInstance: PyodideInterface | null = null;
let astModule: PyProxy | null = null; 
let pyodideLoadPromise: Promise<PyodideInterface | null> | null = null;

const DEBUG_PREFIX = "[PyXOM DEBUG]";

async function initializePyodide(): Promise<PyodideInterface | null> {
  if (typeof window === 'undefined') {
    console.warn(`${DEBUG_PREFIX} Evaluator: Attempted to initialize Pyodide on the server. Skipping.`);
    return null;
  }
  if (pyodideInstance) {
    // console.log(`${DEBUG_PREFIX} Evaluator: Pyodide already initialized.`);
    return pyodideInstance;
  }
  if (pyodideLoadPromise) {
    // console.log(`${DEBUG_PREFIX} Evaluator: Pyodide initialization in progress. Returning existing promise.`);
    return pyodideLoadPromise;
  }

  console.log(`${DEBUG_PREFIX} Evaluator: Loading Pyodide...`);
  // @ts-ignore: loadPyodide está en el scope global
  pyodideLoadPromise = window.loadPyodide({
    indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.25.0/full/', 
  }).then((loadedPyodide: PyodideInterface) => {
    pyodideInstance = loadedPyodide;
    console.log(`${DEBUG_PREFIX} Evaluator: Pyodide loaded. Loading "ast" module...`);
    if (pyodideInstance) {
      astModule = pyodideInstance.pyimport('ast');
      console.log(`${DEBUG_PREFIX} Evaluator: Python "ast" module loaded.`);
    }
    return pyodideInstance;
  }).catch((error: any) => {
    console.error(`${DEBUG_PREFIX} Evaluator: Failed to load Pyodide or "ast" module.`, error);
    pyodideLoadPromise = null; 
    pyodideInstance = null; 
    return null;
  });
  return pyodideLoadPromise;
}

function normalizeOutput(s: string): string {
  if (typeof s !== 'string') return '';
  return s.replace(/\r\n?/g, '\n').trimEnd();
}

async function runSingleTestCase(
  py: PyodideInterface,
  code: string,
  testCase: TestCase,
  globalTimeoutMs: number
): Promise<SingleTestRunResult> {
  
  const timeoutMs = testCase.timeoutMs || globalTimeoutMs || 7000;
  let currentInputIndex = 0;
  const inputs = testCase.input === '' ? [] : testCase.input.split('\n');

  console.log(
    `${DEBUG_PREFIX} Test Case Start: "${testCase.name || 'Unnamed Test'}"`,
    { 
      inputsToProvide: inputs, 
      expectedOutputLength: testCase.expected.length,
      codeSnippet: code.substring(0, 100) + (code.length > 100 ? '...' : '') 
    }
  );

  const originalBuiltins: Record<string, any> = {};
  if (py.globals.has('input')) originalBuiltins.input = py.globals.get('input');

  let capturedOutput = '';
  const customInputImplementation = (prompt?: string) => {
    console.log(
      `${DEBUG_PREFIX} input() called. Current index: ${currentInputIndex}, Total inputs: ${inputs.length}` +
      (prompt ? `, Prompt: "${prompt}"` : "")
    );
    if (currentInputIndex < inputs.length) {
      const val = inputs[currentInputIndex]; // No incrementar aquí todavía
      currentInputIndex++; // Incrementar después de usar el índice actual
      console.log(`${DEBUG_PREFIX} Providing input #${currentInputIndex} (value: "${val}")`);
      return val;
    }
    console.error(`${DEBUG_PREFIX} ERROR: Input requested, but no more inputs available.`);
    throw new Error("[PyXOM Input Error] Se solicitó más entradas (input) de las disponibles para este test.");
  };
  py.globals.set('input', customInputImplementation);

  let stdBuffer = "";
  py.setStdout({ batched: (msg: string) => { stdBuffer += msg + "\n"; } });
  py.setStderr({ batched: (msg: string) => { stdBuffer += msg + "\n"; } }); 

  const startTime = performance.now();
  let executionError: string | undefined;
  let isSuccessExecution = false;

  try {
    const executionPromise = py.runPythonAsync(code);
    const timeoutPromise = new Promise<void>((_, reject) =>
      setTimeout(() => reject(new Error(`[PyXOM Timeout Error] Límite de tiempo (${timeoutMs / 1000}s) excedido.`)), timeoutMs)
    ); 
    console.log(`${DEBUG_PREFIX} Test "${testCase.name || 'Unnamed Test'}": Executing py.runPythonAsync...`);
    await Promise.race([executionPromise, timeoutPromise]);
    isSuccessExecution = true;
    console.log(`${DEBUG_PREFIX} Test "${testCase.name || 'Unnamed Test'}": Python execution successful (no internal Python error).`);
  } catch (e: any) {
    executionError = e.message || String(e);
    isSuccessExecution = false;
    console.error(`${DEBUG_PREFIX} Test "${testCase.name || 'Unnamed Test'}": CAUGHT ERROR during Python execution:`, executionError, e);
  } finally {
    capturedOutput = stdBuffer; 
    if (originalBuiltins.input) py.globals.set('input', originalBuiltins.input); else py.globals.delete('input');
    py.setStdout({}); 
    py.setStderr({});
    console.log(`${DEBUG_PREFIX} Test "${testCase.name || 'Unnamed Test'}": Cleaned up Pyodide globals (input, stdout, stderr).`);
  }

  const durationMs = performance.now() - startTime;
  const normalizedActualOutput = normalizeOutput(capturedOutput);
  const normalizedExpectedOutput = normalizeOutput(testCase.expected);
  const passed = isSuccessExecution && (normalizedActualOutput === normalizedExpectedOutput || testCase.acceptPartial);
  const pointsEarned = passed ? (testCase.points || 0) : 0;

  console.log(
    `${DEBUG_PREFIX} Test Case End: "${testCase.name || 'Unnamed Test'}"`,
    {
      passed,
      isSuccessExecution,
      error: executionError || 'None',
      durationMs: parseFloat(durationMs.toFixed(2)),
      normalizedActualOutputSnippet: normalizedActualOutput.substring(0, 50) + (normalizedActualOutput.length > 50 ? '...' : ''),
      normalizedExpectedOutputSnippet: normalizedExpectedOutput.substring(0, 50) + (normalizedExpectedOutput.length > 50 ? '...' : '')
    }
  );

  return {
    testCase, isSuccessExecution, actualOutput: capturedOutput, normalizedActualOutput,
    passed, durationMs, error: executionError, pointsEarned
  };
}

async function runSingleStaticCheck(
  py: PyodideInterface,
  userCode: string,
  staticCheck: StaticCodeCheck
): Promise<StaticCheckRunResult> {
  console.log(`${DEBUG_PREFIX} Static Check Start: "${staticCheck.id} - ${staticCheck.description}"`);
  let passed = false;
  let message: string | undefined = staticCheck.failureMessage;
  let error: string | undefined;

  if (!astModule) {
    const errMsg = "[PyXOM Static Check Error] Módulo 'ast' de Python no cargado.";
    console.error(`${DEBUG_PREFIX} ${errMsg}`);
    return { check: staticCheck, passed: false, error: errMsg, pointsEarned: 0 };
  }

  try {
    const result = await staticCheck.checkFunction(userCode, py, astModule);
    if (typeof result === 'boolean') {
      passed = result;
      message = passed ? (staticCheck.successMessage || "Comprobación superada.") : (staticCheck.failureMessage || "Comprobación fallida.");
    } else if (typeof result === 'string') {
      passed = false; message = result; // Assume string result is a custom failure message
    }
    console.log(`${DEBUG_PREFIX} Static Check "${staticCheck.id}": Result - ${passed}, Message - ${message || 'N/A'}`);
  } catch (e: any) {
    error = `[PyXOM Static Check Error] Error interno en checkFunction "${staticCheck.id}": ${e.message || String(e)}`;
    passed = false;
    console.error(`${DEBUG_PREFIX} ${error}`, e);
  }
  const pointsEarned = passed ? (staticCheck.points || 0) : 0;
  console.log(`${DEBUG_PREFIX} Static Check End: "${staticCheck.id}". Passed: ${passed}, Points: ${pointsEarned}`);
  return { check: staticCheck, passed, message, error, pointsEarned };
}

export async function evaluateExercise(
  userCode: string,
  exerciseData: ExerciseData
): Promise<Omit<AttemptResult, 'timestamp' | 'overallPassed' | 'testsPassedCount' | 'totalTests' | 'staticChecksPassedCount' | 'totalStaticChecks' | 'totalPointsEarned' | 'maxPossiblePoints' | 'triggeredHints' | 'triggeredPitfalls' >> {
  
  console.log(`${DEBUG_PREFIX} evaluateExercise Start for exercise ID: "${exerciseData.id}"`);
  const py = await initializePyodide(); 
  
  if (!py) { 
    const errorMsg = '[PyXOM Evaluator Error] Pyodide no está disponible.';
    console.error(`${DEBUG_PREFIX} ${errorMsg} in evaluateExercise.`);
    return {
      testRunResults: exerciseData.tests.map(tc => ({
        testCase: tc, isSuccessExecution: false, actualOutput: '', normalizedActualOutput: '',
        passed: false, durationMs: 0, error: errorMsg, pointsEarned: 0
      })),
      staticCheckRunResults: exerciseData.staticCodeChecks?.map(sc => ({
        check: sc, passed: false, error: errorMsg, pointsEarned: 0
      })),
      durationMs: 0
    };
  }

  const overallStartTime = performance.now();
  const testRunResults: SingleTestRunResult[] = [];
  console.log(`${DEBUG_PREFIX} evaluateExercise: Iterating ${exerciseData.tests.length} test cases.`);
  for (const testCase of exerciseData.tests) {
    const result = await runSingleTestCase(py, userCode, testCase, exerciseData.globalTimeoutMs || 7000);
    testRunResults.push(result);
    if (!result.isSuccessExecution) {
      console.log(`${DEBUG_PREFIX} evaluateExercise: Deteniendo tests debido a fallo de ejecución en test: "${testCase.name || 'Unnamed Test'}"`);
      break;
    }
  }

  let staticCheckRunResults: StaticCheckRunResult[] | undefined;
  if (exerciseData.staticCodeChecks && exerciseData.staticCodeChecks.length > 0) {
    console.log(`${DEBUG_PREFIX} evaluateExercise: Iterating ${exerciseData.staticCodeChecks.length} static checks.`);
    staticCheckRunResults = [];
    for (const check of exerciseData.staticCodeChecks) {
      const result = await runSingleStaticCheck(py, userCode, check);
      staticCheckRunResults.push(result);
    }
  } else {
    console.log(`${DEBUG_PREFIX} evaluateExercise: No static checks to run.`);
  }
  const overallDurationMs = performance.now() - overallStartTime;
  console.log(`${DEBUG_PREFIX} evaluateExercise End. Total duration: ${overallDurationMs.toFixed(2)} ms`);

  return { testRunResults, staticCheckRunResults, durationMs: overallDurationMs };
}

export async function getPyodideInstance(): Promise<PyodideInterface | null> {
    console.log(`${DEBUG_PREFIX} getPyodideInstance called.`);
    return initializePyodide();
}

export { initializePyodide, runSingleTestCase };